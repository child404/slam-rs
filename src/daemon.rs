// Runs xrandr, parses its output,
// saves to file, and offers to apply automatically detected layout
use crate::{
    cli::cmd::CmdResult,
    cli::{cmd, xrandr::Xrandr},
    config::LayoutConfig,
    exit_err, find_config_path,
    screen::{Layout, Mode, Orientation, Output, Outputs, Position, State},
};
use daemonize::Daemonize;
use std::{
    fs::{File, OpenOptions},
    io::Write,
    thread, time,
};

const SAVE_DELAY: u64 = 3;
const LAYOUT_FILE: &str = "/tmp/layout.toml";

fn detect_outputs(xrandr: &Xrandr) -> CmdResult<()> {
    let old_outputs_len =
        cmd::run_and_fetch_output(&format!("cat {} | grep \"Connected\"", LAYOUT_FILE))
            .unwrap_or_else(|_| String::new())
            .split('\n')
            .count();
    let new_outputs_len = xrandr.count_connected_outputs().unwrap();
    if old_outputs_len != new_outputs_len {
        let internal_output = "eDP-1";
        let output_modes = xrandr.get_output_modes()?;
        let disconnected_outputs = xrandr.list_disconnected_outputs()?;
        let mut is_primary = true;
        let mut layout = Layout {
            name: "AutoGenerated".to_string(),
            is_current: false,
            outputs: Outputs::with_capacity(output_modes.len() + disconnected_outputs.len()),
        };
        for (output_name, output_mode) in &output_modes {
            let output = Output {
                name: output_name.clone(),
                mode: Mode {
                    resolution: output_mode.resolutions[0],
                    rate: output_mode.rates[0],
                },
                is_primary,
                state: if output_name == internal_output {
                    State::Connected
                } else {
                    State::Duplicated(internal_output.to_string())
                },
                position: Position::Center,
                orientation: Orientation::Normal,
            };
            layout.add(output);
            is_primary = false;
        }
        for output_name in disconnected_outputs {
            layout.add(Output {
                name: output_name,
                ..Output::new()
            })
        }

        let mut layout_to_apply = layout.clone();
        println!(
            "Detected new layout: {} with {} outputs",
            &layout.name, new_outputs_len
        );
        let mut config = LayoutConfig::try_from_toml(&find_config_path()).unwrap();
        let existing_layouts = config.layouts.clone();
        'a: for existing_layout in existing_layouts.values() {
            let existing_layout_active_outputs = existing_layout
                .outputs
                .iter()
                .filter(|(_, output)| !matches!(output.state, State::Disconnected))
                .map(|(_, output)| output.clone())
                .collect::<Vec<Output>>();
            if existing_layout_active_outputs.len() != new_outputs_len {
                continue 'a;
            }
            for output in &existing_layout_active_outputs {
                if let Some(output_mode) = output_modes.get(&output.name) {
                    if !output_mode.resolutions.contains(&output.mode.resolution)
                        || !output_mode.rates.contains(&output.mode.rate)
                    {
                        continue 'a;
                    }
                } else {
                    continue 'a;
                }
            }
            println!("Found existing layout to apply: {}", &existing_layout.name);
            layout_to_apply = existing_layout.clone();
            break;
        }
        if layout.name == layout_to_apply.name {
            println!(
                "Not found existing layout, default will be applied: {}",
                &layout.name
            );
            config.add(&layout_to_apply).unwrap();
        }
        config.apply(&layout_to_apply.name, xrandr).unwrap();
        let mut layout_file = OpenOptions::new()
            .write(true)
            .truncate(true)
            .open(LAYOUT_FILE)
            .unwrap_or_else(|error| exit_err!("Error opening a layout file for write: {}", error));
        layout_file
            .write_all(
                toml::Value::try_from(&layout_to_apply)
                    .unwrap()
                    .to_string()
                    .as_bytes(),
            )
            .unwrap_or_else(|error| exit_err!("Error writing to a layout file: {}", error));
    }
    Ok(())
}

// TODO: add daemon's Error and cast From<daemon::Erorr> for Error in app.rs
// TODO: detect monitors in live using xrandr
pub fn run_daemon() -> CmdResult<()> {
    let stdout = File::create("/tmp/slamd.out")
        .unwrap_or_else(|error| exit_err!("Error creating stdout file: {}", error));
    let stderr = File::create("/tmp/slamd.err")
        .unwrap_or_else(|error| exit_err!("Error creating stderr file: {}", error));
    let daemon = Daemonize::new()
        .pid_file("/tmp/slamd.pid")
        .chown_pid_file(true)
        .working_directory("/tmp")
        .umask(0o777)
        .stdout(stdout)
        .stderr(stderr);

    File::create(LAYOUT_FILE)
        .unwrap_or_else(|error| exit_err!("Error creating temp layout file: {}", error));

    match daemon.start() {
        Ok(_) => {
            let xrandr = Xrandr::default();
            loop {
                detect_outputs(&xrandr)?;
                thread::sleep(time::Duration::from_secs(SAVE_DELAY));
            }
        }
        Err(error) => {
            exit_err!("Error running slamd: {}", error);
        }
    }
}
